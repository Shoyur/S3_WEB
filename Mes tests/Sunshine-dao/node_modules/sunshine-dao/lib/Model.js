"use strict";
/**
 *  JDB - Light MongoDb DAO
 *
 *  MIT License
 *  Copyright (c) 2017 Michael Hasler
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Type = exports.Encrypted = exports.embedded = exports.objectid = exports.Collection = exports.QueryPointer = exports.Model = void 0;
const Document_1 = require("./Document");
const Sunshine_1 = require("./Sunshine");
const EmbeddedModel_1 = require("./EmbeddedModel");
const mongodb_1 = require("mongodb");
class Model extends Document_1.Document {
    constructor(data) {
        super(data);
    }
    save() {
        if (this.hasOwnProperty("_id")) {
            return new Promise((resolve, reject) => {
                const _doc = this.fetchDocument(this, false, true, false);
                const collection = Sunshine_1.Sunshine.getConnection().collection(this.constructor._collection);
                const timestamp = new Date();
                if (this.__updateOnSave)
                    _doc[this.__updateOnSave] = new Date();
                this.encryptDocument(_doc);
                if (collection.replaceOne) {
                    collection.replaceOne({ _id: this._id }, _doc, { upsert: true }, (err, result) => {
                        if (err)
                            reject(err);
                        Model.emit("update", this.constructor._collection, timestamp);
                        resolve(true);
                    });
                }
                else {
                    collection.updateOne({ _id: this._id }, _doc, { upsert: true }, (err, result) => {
                        if (err)
                            reject(err);
                        Model.emit("update", this.constructor._collection, timestamp);
                        resolve(true);
                    });
                }
            });
        }
        else
            return this.create();
    }
    create() {
        return new Promise((resolve, reject) => {
            const _doc = this.fetchDocument(this, false, true, false);
            const collection = Sunshine_1.Sunshine.getConnection().collection(this.constructor._collection);
            const timestamp = new Date();
            if (this.__updateOnSave)
                _doc[this.__updateOnSave] = new Date();
            this.encryptDocument(_doc);
            collection.insertOne(_doc, (err, result) => {
                if (err)
                    reject(err);
                this._id = result.insertedId;
                Model.emit("insert", this.constructor._collection, timestamp);
                resolve(true);
            });
        });
    }
    static findOneDiscrete(query, type, collection) {
        return new Promise((resolve, reject) => {
            const _collection = (collection) ? collection : this._collection;
            const timestamp = new Date();
            Sunshine_1.Sunshine.getConnection().collection(_collection).findOne(query, (err, result) => {
                Model.emit("query", _collection, timestamp);
                if (err) {
                    reject(err);
                    return;
                }
                if (!result || result === null) {
                    resolve(null);
                    return;
                }
                let t = null;
                if (type)
                    t = (new type()).__elevate(result);
                else
                    t = (new this()).__elevate(result);
                if (t._autoPopulate) {
                    t.populateAll().then(success => {
                        resolve(t);
                    });
                }
                else {
                    resolve(t);
                }
            });
        });
    }
    static findOne(query, options) {
        const timestamp = new Date();
        return new Promise((resolve, reject) => {
            Sunshine_1.Sunshine.getConnection().collection(this._collection).findOne(query, options, (err, result) => {
                Model.emit("query", this._collection, timestamp);
                if (err) {
                    reject(err);
                    return;
                }
                if (!result || result === null) {
                    resolve(null);
                    return;
                }
                // parse doc
                const t = (new this()).__elevate(result);
                // parse embedded
                if (this.prototype && this.prototype._embedded) {
                    for (const em of this.prototype._embedded) {
                        if (t[em] instanceof Array) {
                            t[em] = t[em].map(element => {
                                return new EmbeddedModel_1.EmbeddedModel(element);
                            });
                        }
                    }
                }
                if (t.__autoPopulate) {
                    t.populateAll().then(success => {
                        resolve(t);
                    });
                }
                else {
                    resolve(t);
                }
            });
        });
    }
    static find(query, fields, collection) {
        let _collection = (collection) ? collection : this._collection;
        let queryPointer = Sunshine_1.Sunshine.getConnection().collection(_collection).find(query, { projection: fields });
        return new QueryPointer(queryPointer, this);
    }
    static aggregate(query, options) {
        let _collection = this._collection;
        let queryPointer = Sunshine_1.Sunshine.getConnection().collection(_collection).aggregate(query, options);
        return new QueryPointer(queryPointer, this);
    }
    static group(query) {
        let _collection = this._collection;
        let queryPointer = Sunshine_1.Sunshine.getConnection().collection(_collection).group(query);
        return new QueryPointer(queryPointer, this);
    }
    static groupT(query) {
        let _collection = this._collection;
        return new Promise((resolve, reject) => {
            let queryPointer = Sunshine_1.Sunshine.getConnection().collection(_collection).group(query, {}, {}, results => {
                resolve(results);
            });
        });
    }
    /**
     *
     * @deprecated Please use updateOne, updateMany
     */
    static update(criteria, update, options) {
        const _collection = this._collection;
        const timestamp = new Date();
        return new Promise((resolve, reject) => {
            Sunshine_1.Sunshine.getConnection()
                .collection(_collection)
                .update(criteria, update, options, function (err, result) {
                if (err)
                    reject(err);
                Sunshine_1.Sunshine.getConnection()
                    .collection(_collection)
                    .update(criteria, {
                    $set: { updated: new Date() }
                }, {}, function (err, result) {
                    Model.emit("query", _collection, timestamp);
                    resolve(result);
                });
            });
        });
    }
    static updateOne(criteria, update, options) {
        const _collection = this._collection;
        const timestamp = new Date();
        if (update.$set) {
            update.$set.updated = new Date();
        }
        else {
            update.$set = {
                updated: new Date()
            };
        }
        return new Promise((resolve, reject) => {
            Sunshine_1.Sunshine.getConnection()
                .collection(_collection)
                .updateOne(criteria, update, options, function (err, result) {
                if (err)
                    reject(err);
                Model.emit("query", _collection, timestamp);
                resolve(result);
            });
        });
    }
    static updateMany(criteria, update, options) {
        const _collection = this._collection;
        const timestamp = new Date();
        if (update.$set) {
            update.$set.updated = new Date();
        }
        else {
            update.$set = {
                updated: new Date()
            };
        }
        return new Promise((resolve, reject) => {
            Sunshine_1.Sunshine.getConnection()
                .collection(_collection)
                .updateMany(criteria, update, options, function (err, result) {
                if (err)
                    reject(err);
                Model.emit("query", _collection, timestamp);
                resolve(result);
            });
        });
    }
    static collection() {
        return Sunshine_1.Sunshine.getConnection().collection(this._collection);
    }
    async populate(type, _id, name, collection) {
        let _name = "_" + name;
        if (this[_name]) {
            return this[_name];
        }
        else {
            this[_name] = await Model.findOneDiscrete({ _id: _id }, type, collection);
        }
        return this[_name];
    }
    async populateMany(type, _ids, name, collection) {
        let _name = "_" + name;
        if (this[_name]) {
            return this[_name];
        }
        else {
            this[_name] = await Model.find({ _id: { $in: _ids } }, {}, collection).toArray(type);
        }
        return this[_name];
    }
    populatable() {
        return {};
    }
    /**
     * @deprecated Use deleteOne or deleteMany
     * @param query
     */
    static remove(query) {
        return new Promise((resolve, reject) => {
            let _collection = this._collection;
            Sunshine_1.Sunshine.getConnection().collection(_collection).remove(query, function (err, result) {
                if (err)
                    reject(err);
                resolve(result);
            });
        });
    }
    /**
     * Deletes only 1 entry from the database
     * Can be used with object or ObjectId as a parameter
     * @param query
     */
    static deleteOne(query) {
        return new Promise((resolve, reject) => {
            let _query;
            if (query instanceof mongodb_1.ObjectId) {
                _query = { _id: query };
            }
            else {
                _query = Object.assign({}, query);
            }
            let _collection = this._collection;
            Sunshine_1.Sunshine.getConnection().collection(_collection).deleteOne(_query, function (err, result) {
                if (err)
                    reject(err);
                resolve(result);
            });
        });
    }
    /**
     * Deletes every document in the database that matches the query
     * @param query
     */
    static deleteMany(query) {
        return new Promise((resolve, reject) => {
            let _collection = this._collection;
            Sunshine_1.Sunshine.getConnection().collection(_collection).deleteMany(query, function (err, result) {
                if (err)
                    reject(err);
                resolve(result);
            });
        });
    }
    // TODO: Remove double assing of attriubte
    async populateAll() {
        let list = this.populatable();
        for (let key in this.populatable()) {
            let many = list[key].many;
            // If entry does not have reference set (null)
            if (!this[list[key].reference])
                continue;
            if (!list[key].many) {
                let value = list[key];
                await this.populate(value.type, this[value.reference], key, value.collection);
            }
            else {
                let value = list[key];
                await this.populateMany(value.type, this[value.reference], key, value.collection);
            }
        }
        return true;
    }
    /**
     * Emit update/query events
     * @private
     */
    static emit(event, collection, timestamp) {
        Sunshine_1.Sunshine.event(event, {
            collection: collection, runtime: (new Date()).getTime() - timestamp.getTime()
        });
    }
}
exports.Model = Model;
class QueryPointer {
    constructor(queryPointer, document) {
        this._queryPointer = queryPointer;
        this._document = document;
        this._timestamp = new Date();
    }
    sort(query) {
        this._queryPointer.sort(query);
        return new QueryPointer(this._queryPointer, this._document);
    }
    limit(limit) {
        this._queryPointer.limit(limit);
        return new QueryPointer(this._queryPointer, this._document);
    }
    skip(limit) {
        this._queryPointer.skip(limit);
        return new QueryPointer(this._queryPointer, this._document);
    }
    collation(properties) {
        this._queryPointer.collation(properties);
        return new QueryPointer(this._queryPointer, this._document);
    }
    projection(fields) {
        this._queryPointer.project(fields);
        return new QueryPointer(this._queryPointer, this._document);
    }
    // --- Close Pipeline -------------------------------------------------------
    async count() {
        const result = await this._queryPointer.count();
        this.emit();
        return result;
    }
    async toArray(type) {
        return await new Promise((resolve, reject) => {
            let results = this._queryPointer.toArray((err, results) => {
                if (err)
                    reject(err);
                this.emit();
                let promises = [];
                let documents = [];
                // empty result set, return empty array
                if (!results || results === null) {
                    resolve([]);
                    return;
                }
                if (type) {
                    results.forEach(doc => {
                        let t = (new type()).__elevate(doc);
                        if (t.__autoPopulate)
                            promises.push(t.populateAll());
                        documents.push(t);
                    });
                }
                else {
                    results.forEach(doc => {
                        let t = (new this._document()).__elevate(doc);
                        if (t.__autoPopulate)
                            promises.push(t.populateAll());
                        documents.push(t);
                    });
                }
                Promise.all(promises).then(result => {
                    resolve(documents);
                });
            });
        });
    }
    /**
     * Emit update/query events
     * @private
     */
    emit() {
        Sunshine_1.Sunshine.event("query", {
            collection: this._queryPointer.namespace.collection,
            runtime: (new Date()).getTime() - this._timestamp.getTime()
        });
    }
}
exports.QueryPointer = QueryPointer;
/**
 * Decorator for Collection-name
 *
 * @param {string} name
 * @returns {(target) => any}
 * @constructor
 */
function Collection(name) {
    return (target) => {
        target._collection = name;
    };
}
exports.Collection = Collection;
/**
 * Decorator for objectId type
 */
function objectid() {
    return (target, key) => {
        let pKey = `_${key}`;
        // called at runtime to access (this) as instance of class
        let init = function (isGet) {
            return function (newVal) {
                // Hidden property
                Object.defineProperty(this, pKey, { value: 0, enumerable: false, configurable: true, writable: true });
                // Public property
                Object.defineProperty(this, key, {
                    get: () => {
                        return this[pKey];
                    },
                    set: (val) => {
                        if (val instanceof mongodb_1.ObjectId) {
                            this[pKey] = val;
                        }
                        else {
                            try {
                                this[pKey] = mongodb_1.ObjectId.createFromHexString(val);
                            }
                            catch (exception) {
                                this[pKey] = null;
                            }
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                // Set / get values
                if (isGet) {
                    return this[key];
                }
                else {
                    this[key] = newVal;
                }
            };
        };
        // Will be called on first execution and replaced
        return Object.defineProperty(target, key, {
            get: init(true),
            set: init(false),
            enumerable: true,
            configurable: true
        });
    };
}
exports.objectid = objectid;
//}
/**
 * Reference embedded
 *
 * @param {boolean} value
 * @returns {(target: any, propertyKey: string, descriptor: PropertyDescriptor) => any}
 */
// TODO: Complete embedded parsing
function embedded() {
    return function (target, propertyKey) {
        if (!target._embedded)
            target._embedded = [];
        target._embedded.push(propertyKey);
    };
}
exports.embedded = embedded;
/**
 * Reference encrypted
 *
 * @param {boolean} value
 * @returns {(target: any, propertyKey: string, descriptor: PropertyDescriptor) => any}
 */
// TODO: Complete embedded parsing
function Encrypted() {
    return function (target, propertyKey) {
        if (!target.__encryptedFields)
            target.__encryptedFields = [];
        target.__encryptedFields.push(propertyKey);
    };
}
exports.Encrypted = Encrypted;
/*
export function Type() {
    return function (target: any, propertyKey: string) {
        if (!target.__dynamicTypes) target.__dynamicTypes = [];
        target.__dynamicTypes.push(propertyKey);
    };
}
 */
function Type(parser) {
    return (target, key) => {
        if (!target.__dynamicTypes)
            target.__dynamicTypes = {};
        target.__dynamicTypes[key] = parser;
    };
}
exports.Type = Type;
