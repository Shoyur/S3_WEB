/**
 *  JDB - Light MongoDb DAO
 *
 *  MIT License
 *  Copyright (c) 2017 Michael Hasler
 */
import { Document } from "./Document";
import { ObjectId, Collection, FilterQuery, DeleteWriteOpResultObject } from "mongodb";
export declare class Model extends Document {
    static _collection: string;
    _embedded: Array<string>;
    _id: ObjectId;
    constructor(data?: any);
    save(): Promise<boolean>;
    create(): Promise<boolean>;
    static findOneDiscrete<T extends Model>(query: any, type?: {
        new (): T;
    }, collection?: string): Promise<T>;
    static findOne<T extends Model>(query: any, options?: object): Promise<T>;
    static find<T extends Model>(query: any, fields?: any, collection?: string): QueryPointer<T>;
    static aggregate<T extends Model>(query: any, options?: any): QueryPointer<T>;
    static group<T extends Model>(query: any): QueryPointer<T>;
    static groupT<T extends Model>(query: any): Promise<Array<T>>;
    /**
     *
     * @deprecated Please use updateOne, updateMany
     */
    static update(criteria: any, update: any, options?: any): Promise<any>;
    static updateOne(criteria: any, update: any, options?: any): Promise<any>;
    static updateMany(criteria: any, update: any, options?: any): Promise<any>;
    static collection(): Collection;
    populate<T extends Model>(type: {
        new (): T;
    }, _id: ObjectId, name: string, collection: string): Promise<T>;
    populateMany<T extends Model>(type: {
        new (): T;
    }, _ids: Array<ObjectId>, name: string, collection: string): Promise<Array<T>>;
    protected populatable(): {};
    /**
     * @deprecated Use deleteOne or deleteMany
     * @param query
     */
    static remove(query: any): Promise<boolean>;
    /**
     * Deletes only 1 entry from the database
     * Can be used with object or ObjectId as a parameter
     * @param query
     */
    static deleteOne(query: FilterQuery<any> | ObjectId): Promise<DeleteWriteOpResultObject>;
    /**
     * Deletes every document in the database that matches the query
     * @param query
     */
    static deleteMany(query: any): Promise<DeleteWriteOpResultObject>;
    populateAll(): Promise<boolean>;
    /**
     * Emit update/query events
     * @private
     */
    private static emit;
}
export declare class QueryPointer<T extends Model> {
    private _queryPointer;
    private _document;
    private _timestamp;
    constructor(queryPointer: any, document: any);
    sort(query: object): QueryPointer<T>;
    limit(limit: number): QueryPointer<T>;
    skip(limit: number): QueryPointer<T>;
    collation(properties: {
        locale?: string;
        caseLevel?: boolean;
        caseFirst?: string;
        strength?: number;
        numericOrdering?: boolean;
        alternate?: string;
        maxVariable?: string;
        backwards?: boolean;
    }): QueryPointer<T>;
    projection(fields: object): QueryPointer<T>;
    count(): Promise<number>;
    toArray(type?: {
        new (): T;
    }): Promise<Array<T>>;
    /**
     * Emit update/query events
     * @private
     */
    private emit;
}
/**
 * Decorator for Collection-name
 *
 * @param {string} name
 * @returns {(target) => any}
 * @constructor
 */
export declare function Collection(name: string): (target: any) => void;
/**
 * Decorator for objectId type
 */
export declare function objectid(): (target: any, key: string) => any;
/**
 * Reference embedded
 *
 * @param {boolean} value
 * @returns {(target: any, propertyKey: string, descriptor: PropertyDescriptor) => any}
 */
export declare function embedded(): (target: any, propertyKey: string) => void;
/**
 * Reference encrypted
 *
 * @param {boolean} value
 * @returns {(target: any, propertyKey: string, descriptor: PropertyDescriptor) => any}
 */
export declare function Encrypted(): (target: any, propertyKey: string) => void;
export declare function Type(parser: (value: any) => any): (target: any, key: string) => void;
